/*
parser analyzes the sequence of tokens produced by the lexer and determines their grammatical structure based on a formal grammar 
*/
import java.util.List;

public class Parser{
    private  List<Token> tokens;
    private int currentToken;

    //intializes the token and the currentToken pointer
    public Parser(List<Token> tokens){
        this.tokens = tokens;
        this.currentToken = 0;
    }
    //method to start parsing the source code
    public void parse(){
        try{
            program();
           // if(currentToken == tokens.size()){
                System.out.println("The Source Code is generated by the BNF grammar");
           // }
        }catch(ParseException e){
            System.out.println("The Source Code cannot be generated by the Sample Function defined language, and identify the error.");
            System.err.println("Syntax Error: " + e.getMessage());
           // return;
        }
    }
//method to parse the program's structure 
    private void program() throws ParseException {
        match("KEYWORD");
        match("IDENTIFIER");
        match("LPAREN");
        match("RPAREN");
        match("LBRACE");
        declares();
        stmts();
        loop();
        stmts();
        match("RBRACE");
    }
    //method to parse declarations
    private void declares() throws ParseException {
        while(currentToken < tokens.size() && tokens.get(currentToken).getType().equals("KEYWORD")){
           match("KEYWORD");
           match("IDENTIFIER");
            match("SEMICOLON");
        }
    }
    //method to parse statements 
    private void stmts() throws ParseException {
        while(currentToken < tokens.size() && tokens.get(currentToken).getType().equals("IDENTIFIER")){
            assign();
            match("SEMICOLON");
        }
    }
    //method to parse an assignment 
    private void assign() throws ParseException {
        match("IDENTIFIER");
        match("ASSIGNMENT_OPERATOR");
        expr();
    }
    //method to parse an expression
    private void expr() throws ParseException {
        match("IDENTIFIER");
        if (currentToken < tokens.size() &&
                (tokens.get(currentToken).getType().equals("MULTIPLY_OPERATOR") ||
                        tokens.get(currentToken).getType().equals("DIVIDE_OPERATOR"))) {
            match(tokens.get(currentToken).getType());
            expr();
        }
    }
    //method to parse a loop structure
    private void loop() throws ParseException {
        match("KEYWORD");     
        match("LPAREN");        
        match("IDENTIFIER");    

        // Handle relational operators
        if (tokens.get(currentToken).getType().equals("GREATER_THAN_EQUAL_OPERATOR") ||
                tokens.get(currentToken).getType().equals("LESS_THAN_OPERATOR") ||
                tokens.get(currentToken).getType().equals("GREATER_THAN_OPERATOR") ||
                tokens.get(currentToken).getType().equals("LESS_THAN_EQUAL_OPERATOR")) {
            match(tokens.get(currentToken).getType());  // Match the relational operator
        } else {
            throw new ParseException("Expected a relational operator (>=, <=, >, <), but found: " +
                    tokens.get(currentToken).getType() + " with value '" +
                    tokens.get(currentToken).getValue() + "'");
        }

        match("NUMBER");        
        match("RPAREN");        

        // Check for either a block  or a single statement
        if (tokens.get(currentToken).getType().equals("LBRACE")) {
            match("LBRACE");    {
            stmts();            
            match("RBRACE");    }
        } else {
            stmts();
        }
    }


    //method to check if the current token matches the expected 
    private void match(String expectedType) throws ParseException{
        if(currentToken < tokens.size() && tokens.get(currentToken).getType().equals(expectedType)){
            currentToken++;
        }else{
            throw new ParseException("Expected "+ expectedType + ", but found " + (currentToken < tokens.size() ? tokens.get(currentToken).getType()
                    :"end of input") + ". Token value: "+ (currentToken < tokens.size() ? tokens.get(currentToken).getValue() : "end of input"));
        }
    }

    //custom ParseException to handle syntax errors
    static class ParseException extends Exception {
        ParseException(String message){
            super(message);
        }
    }




}
